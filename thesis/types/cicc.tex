
\newtheorem{tcases}{Case}


\section{Caledon Implicit Calculus of Constructions}


In these sections I lay out the type system for Caledon. I first describe the target system,
on which has meaningful theorems, $CICC$. 
This is the interpreter output of successfully running a Caledon program. 
I then describe the $CICC$ syntax and statics. 
Caledonâ€™s exposed type system is a variant of the Implicit Calculus of Constructions, ICC [53],
which for the rest of the paper I will refer to as $CICC^-$. The $CICC^-$ statics are realized
by the interpretation of the unification problem form ($UPF$) generated by elaboration.
The syntactic pipeline is as follows:


\[
CICC^- \rightarrow UPF \rightarrow CICC
\]

Proving the consistency of $CICC$ requires a further elaboration into $CC$

\begin{figure}[H]
\[ 
E ::= 
V 
\orr S 
\orr E\;E 
\orr \lambda V : T. E 
\orr ?\lambda V,V : T. E 
\orr \Pi V : E . E 
\orr ?\Pi V,V : E . E 
\orr E \{ V : E = E \}
\]

\caption{Syntax of $CICC$}
\label{cicc:syntax}
\end{figure}

In the rest of the thesis, $?\Pi v : E_1 . E_2$ shall refer to
$?\Pi v,v : E_1. E_2$ and $?\lambda v : E_1 . E_2$ shall refer to 
$?\lambda v,v : E_1 . E_2$.

The \textit{dependent} explicit and implicit products are written $\Pi v : E . E $ and $?\Pi v : A . E$. 
The \textit{non-dependent} explicit and implicit products are written $T \rightarrow T$ 
and $T \Rightarrow T$ respectively.

Before providing typing rules, we first supply a few definitions which clarify 
the notion of a constrained name of a term.

\begin{definition}
The constrained names on a term, written $CN(M)$ is a set defined as follows:

\begin{align}
CN(M \{ x = E \}) &= \{ x \} \cup CN(M)
\\
CN(\m{otherwise}) &= \emptyset
\end{align}

\end{definition}

The constrained names on a term are defined to be the constraints placed at the top level on 
a term.  For example, in the term $\m{some_pred} \; \m{type} \; \m{nat} \{ A = nat \} \{ B = nat \}$ the constrained names are $A$ and $B$.  

\begin{definition}
The generalized names for a term, written $GN(M)$ is a set defined as follows:

\begin{align}
GN(?\Pi n,x : T . M) &= \{ n \} \cup GN(M) \cup GN(T)
\\
GN(\m{otherwise}) &= \emptyset
\end{align}
\end{definition}

The definition of generalized names and of constrained names are in a way complimentary.
Only the generalized names of the type of a term may be constrained.

\begin{definition}
The bound names for a term, written $BN(M)$ is a set defined as follows:

\begin{align} 
BN(?\lambda n,x : T . M) &= \{ n \} \cup BN(M)
\\
BN(\m{otherwise}) &= \emptyset
\end{align}

\end{definition}

As defined above, bound names and bound variables can no longer be treated the same in the semantics.  
Specifically, $?\lambda x : A . B$ does not have the same semantics as $?\lambda y : A . [y / x] B$.  
This implies that alpha conversion is now limited.  

There are a few ways to deal with this.  
The most attractive possibility is to interpret names as a kind of record modifier.
This can be seen as saying $\{ x : T = N \} : \{ x : N \}$, 
and $?\lambda x : N . B$ is really just $\lambda y : \{ x : N \} . [ y.x / x ] N$ where $ .x : \{ x : N \} \rightarrow N$.

\begin{figure}[H]
\begin{lstlisting}
defn nat : prop 
  as [a : prop] a -> (a -> a) -> a

defn nat_1 : nat -> prop
  as \ N : nat . [a : nat -> prop] a zero -> succty a -> a N

defn rec : nat -> prop -> prop
  as \ nm : nat . \ N : kind . nat_1 nm * N

defn get : [N : kind] [nm : nat] nat_1 nm * N -> N
  as \ N : kind . \nm : nat . \ c : (nat_1 nm, N) . snd c

defn put : [N : kind] [nm : nat] nat_1 nm ->  N -> nat_1 nm * N
  as \ N : kind . \nm : nat . \nmnm : nat_1 nm . \ c : N . pair nmnm N
\end{lstlisting}
\caption{Definitions for extraction, written in $CC$ with Caledon syntax}
\label{code:ideal}
\end{figure}

We can further convert this into traditional dependent types by constructing
 type invariants as seen in \ref{code:ideal}.   Note that we shall refer loosely 
to the encoding in church numerals of a name $x$ as $\bar{x}$.  $\bar{\bar{x}}$ refers to the 
inhabitant of the type $\m{nat_1}\;\bar{x}$.   $\m{get}$ and $\m{put}$ shall be used as 
aliases for the definitions outlined above.

Then $?\lambda nm,x : A . B$ and $?\Pi nm,x : A . B$ 
becomes $\lambda y : \m{rec}\;\bar{nm}\;A . [get \;A \;\bar{nm}\; y / x ] B$
and $?\Pi y : \m{rec}\;\bar{nm}\;A . [get A \bar{nm} y / x ] B$.

Similarly, $N \{ x\; : \; T \; = \;A \} $
would become $N\;( \m{put} \; T \; \bar{x} \; \bar{\bar{x}} \; A)$.

One might notice that $N$ in $\m{get}$ is of type $\m{kind}$.  
In simple $CC$, this is unfortunately not an actual type. 
Rather, it refers to the use of either $\m{type}$ or $\m{prop}$.  
Allowing $N : \m{type}$ is not permitted in the standard $CC$ since it is quantified.
This is possible in $CC_\omega$ however.
In this case, $\m{kind}$ would always refer to the next universe after the highest
universe mentioned in the program.
In the Caledon language implementing simple $CC$ we are free to define 
$\m{kind}$ as $\m{type}_1$, since it will always be larger than any
type or kind mentioned in a Caledon program.  
Fortunately, Geuvers' proof \citep{geuvers1993logics} of strong normalization in the presence of 
$\eta$ conversion applies to the Calculus of Construction with one impredicative universe and two predicative
universes.

This intuitive conversion leads to the following typing rules for $CICC$.


The simplest, albeit not the most constructive method of defining typeability for $CICC$ can be obtained by a simple projection into $CC$.

\newcommand{\CICCproj}[1]{ \left\llbracket #1 \right\rrbracket_{ci}}

\begin{definition}
\textbf{ (Projection from $CICC$ to $CC$) }

\begin{align}
\CICCproj{v} &:= v
\\
\CICCproj{s} &:= s
\\
\CICCproj{E_1 \; E_2} &:= \CICCproj{E_1} \; \CICCproj{E_2}
\\
\CICCproj{E_1 \; \{ x : T = E \}} &:= \CICCproj{E_1} \; (\m{put}\;\CICCproj{T}\;\bar{x}\; \bar{\bar{x}}; \CICCproj{E_2} )
\\
\CICCproj{\lambda nm,v : T . E } &:= \lambda v : \CICCproj{T} . \CICCproj{E}
\\
\CICCproj{?\lambda nm,v : T . E } &:= \lambda y : \m{rec}\;\bar{nm}\; \CICCproj{T} . \CICCproj{ [ \m{get}\; \CICCproj{T}\; \bar{nm}\; y  / v ] E}
\;\text{ where $y$ is fresh}
\\
\CICCproj{\Pi v : T . E } &:= \Pi v : \CICCproj{T} . \CICCproj{E}
\\
\CICCproj{?\Pi nm,v : T . E } &:= \Pi y : \m{rec}\;\bar{nm}\;\CICCproj{T} . \CICCproj{ [ \m{get}\;\CICCproj{T}\; \bar{nm}\; y  / v ] E}
\;\text{ where $y$ is fresh}
\end{align}

\label{cicc:proj}
\end{definition}

It is significant that church numerals be used for the representation of the name in the record, 
as no extra axioms need to be included in the context of the translation for the translation to be valid.  
This necessity is seen in \ref{ci:sound}.

\begin{definition}
\textbf{(Typing for $CICC$)} We say $\Gamma \vdash_{ci} A : T$ iff $\CICCproj{\Gamma} \vdash_{cc} \CICCproj{A} : \CICCproj{T}$
\label{cicc:typing}
\end{definition}

What is then important is that we can translate back from the calculus of constructions after 
transformations have occurred.

\begin{theorem}
\textbf{(Projection Substitution)}  

$\CICCproj{[A/x] B} = [ \CICCproj{A} / x ] \CICCproj{B}$ provided $x$ is free for $A$ in $B$.

\end{theorem}

The proof of this theorem is by induction on the structure of B.

\begin{tcases}
Suppose $B$ is the variable $x$.
\end{tcases}

$\CICCproj{[A/x] x} = \CICCproj{A} = [\CICCproj{A}/x]x = [\CICCproj{A} / x ] \CICCproj{x}$

\begin{tcases}
Suppose $B$ is a different variable $v$.
\end{tcases}

$\CICCproj{[A/x] v} = v = [\CICCproj{A}/x]v = [\CICCproj{A} / x ] \CICCproj{v}$

\begin{tcases}
The most interesting case is $B = ?\lambda nm,v : T . E$
\end{tcases}

Then
\[
[\CICCproj{A}/x ]\CICCproj{?\lambda nm,v : T . E } 
= [ \CICCproj{A} / x ] ( \lambda v : \m{rec} \; \bar{nm} \;\CICCproj{T} . 
   \CICCproj{ [ \m{get} \; \CICCproj{T} \; \bar{nm} \; y / v ] E } )
\]

where $y$ is fresh.

Then 
\[
= ( \lambda v : \m{rec} \; \bar{nm} \;([ \CICCproj{A} / x ] \CICCproj{T}) . 
    [ \CICCproj{A} / x ] \CICCproj{ [ \m{get} \; \CICCproj{T} \; \bar{nm} \; y / v ] E } )
\]
\[
= ( \lambda v : \m{rec} \; \bar{nm} \;\CICCproj{[ A / x] T} . 
    [ \CICCproj{A} / x ] [ \m{get} \; \CICCproj{T} \; \bar{nm} \; y / v ] \CICCproj{E} )
\]

Then by the induction hypothesis on $T$ and $E$ and the fact that 
$[\CICCproj{A} / x ] \m{get} = \m{get}$ 
and $[\CICCproj{A} / x ] \m{rec} = \m{rec}$ 
and $x \neq y$ since $y$ is fresh, we get: 

\[
= ( \lambda v : \m{rec} \; \bar{nm} \;\CICCproj{[ A / x] T} . 
   [ \m{get} \; \CICCproj{[A / x ]T} \; \bar{nm} \; y / v ]  [ \CICCproj{A} / x ] \CICCproj{E } )
\]
since we know that $v$ isn't free in $A$ by the fact that $x$ is free for $A$ in $B$ 
(provided $x$ is actually used anywhere in $E$) we get the following:
\[
= ( \lambda v : \m{rec} \; \bar{nm} \;\CICCproj{[ A / x] T} . 
   \CICCproj{ [ \m{get} \; \CICCproj{[A / x ]T} \; \bar{nm} \; y / v ] [ A / x ] E } )
\]
\[
= \CICCproj{ ?\lambda nm,v : [ A / x] T . [ A / x ] E }
\]
\[
= \CICCproj{ [ A / x] (?\lambda nm,v : T . E) }
\]

\begin{lemma}
\textbf{(Reduction Translation)}
Forall $M, N \in \m{Term}_{ci}$ if $M \rightarrow_{\beta\eta*} N$ then 
$\CICCproj{M} \rightarrow_{\beta\eta*} \CICCproj{N}$
\label{cicc:red}
\end{lemma}

Proof of this lemma is by lexicographic induction on the structure of $M \rightarrow N$ and $M$.

\begin{theorem}
\textbf{(Semantic Equivalence)}

Forall $M \in \m{Term}_{ci}$ such that $\CICCproj{M} \rightarrow_{\beta\eta*} N'$ and 
$\Gamma \vdash M : T$ implies that there exists $M' \in \m{Term}_{cicc}$ such that 
$M \rightarrow_{\beta\eta*} M'$ and $\CICCproj{M'} \equiv N'$

\label{cicc:equiv}
\end{theorem}

The proof is by induction on the form of $\CICCproj{M} \rightarrow_{\beta\eta} N'$
and then induction to arbitrary numbers of reductions.  

Here we only show the case of $\beta$ reduction.  $\eta$ reduction/expansion is analogous.

Now assume $\CICCproj{M} \rightarrow_{\beta\eta} N'$ is of the form 
$\CICCproj{E} \rightarrow_{\beta} V$.  
Then it is of the form $(\lambda x : T_a . R) E_2 \rightarrow_{beta} [ \CICCproj{E_2}/ x ] R $
where $V = [ \CICCproj{E_2} / c ] R$ and $(\lambda x : T_a . R) E_2 = \CICCproj{E_1} E_2 = \CICCproj{E}$.

Then since $\CICCproj{E_1} = (\lambda x : T_a . R)$ we know that $E_1 = \lambda x : T_a' . R'$ 
or that $E_1 = ?\lambda nm,v : T_a' . R'$.  We examine these two cases.

\setcounter{tcases}{0}

\begin{tcases}
We begin with the case of $E_1 = \lambda x : T_a' . R'$
\end{tcases}

Then because $\Gamma \vdash_{ci} M : T$ and $M = (\lambda x : T_a' . R') E'_2$, 
we know that $\Gamma \vdash_{ci} (\lambda x : T_a' . R') : \Pi x : T_a' . T_2$.
and thus 
$\CICCproj{\Gamma} \vdash_{cc} 
\CICCproj{(\lambda x : T_a' . R')} : \CICCproj{\Pi x : T_a' . T_2}$.

Then $\CICCproj{\Gamma} \vdash_{cc} (\lambda x : \CICCproj{T_a'} . \CICCproj{R'}) \CICCproj{E_2} : \CICCproj{T}$ is the result of the ``app'' rule.  

Since the ``app'' rule has to have been applied, we know that 
$\CICCproj{M} = 
\CICCproj{(\lambda x : T_a' . R') E_2} 
= (\lambda x : \CICCproj{T_a'} . \CICCproj{R'}) \CICCproj{E_2}$.

Thus, $\CICCproj{E_2'} = E_2$ and $\CICCproj{T_a'} = T_a$ and $\CICCproj{R'} = R$. 

Since we are performing a $\beta$ reduction, we know that $x$ is free for $\CICCproj{E_2}$ in 
$\CICCproj{R'}$.  Then by the projection substitution theorem \ref{cicc:proj}, 
$\CICCproj{[E_2/x]R'} = [ \CICCproj{E_2} / x ] \CICCproj{R'} $ where $\CICCproj{R'} = R$.

Thus, $\CICCproj{[E_2 / x] R'} = V$

\begin{tcases}
The last case is where $E_1 = ?\lambda nm,x : T' . R'$
\end{tcases}

Because $\Gamma \vdash_{ci} M : T$ and $M = (?\lambda nm,x : T_a' . R') E_2'$
we know that $\Gamma \vdash_{ci} (?\lambda x : T_a' . R') : ?\Pi nm,x : T_a' . T_2$ clearly.  

Then $\CICCproj{\Gamma} \vdash_{cc} \CICCproj{?\lambda nm,x : T_a' . R'} E_2 : \CICCproj{T}$
 must be the result of the is the result of the ``app'' rule. 

Thus, we know that $\CICCproj{\Gamma} \vdash_{cc} \CICCproj{?\lambda nm,x : T_a' . R'} : \Pi y : T_3 . T_4$ for some $T_3$ and $T_4$.

By uniqueness of forms and inversions, we get that 
\[
\Pi y : T_3 . T_4 
= \Pi y : \m{rec} \bar{nm}\CICCproj{T_a'} . \CICCproj{[ \m{get} \CICCproj{T_a'} \bar{nm} y / x ] T_2}
\]
since 
\[
\CICCproj{?\lambda nm,x : T_a' . R'} 
= 
\lambda y : \m{rec} \bar{nm}\CICCproj{T_a'} . \CICCproj{[ \m{get} \CICCproj{T_a'} \bar{nm} y / x ] R'}
\]

Thus, we know that 
\[
\CICCproj{M} = 
\CICCproj{(?\lambda nm,x : T_a' . R')} (\m{put} \CICCproj{T'}\bar{nm}\bar{\bar{nm}} \CICCproj{E_2})
\]

Thus, $M = (?\lambda nm,x : T_a' . R')\{ nm : T_2' = E_2\} $ and $\CICCproj{T_a'} = T$ 
and $\CICCproj{R'} = R$.  Since we are performing a $\beta$ reduction, we know that
$x$ is free for $\CICCproj{E_2}$ in $\CICCproj{R'}$.  
Then by the projection substitution theorem \ref{cicc:proj}, 
$\CICCproj{[E_2/x]R'} = [ \CICCproj{E_2}/x ] \CICCproj{R'}$
where $\CICCproj{R'} = R$

Thus, $\CICCproj{[E_2/x] R'} = V$



\begin{theorem}
\textbf{(Strong Normalization)} $\forall M \in \m{Term}_{ci}. SN(M)$
\label{ci:sn}
\end{theorem}

Strong normalization is a consequence of the reduction translation lemma \ref{cicc:red}.

That we can cleanly translate into the calculus of constructions without loss or gain of 
semantic translation implies strong normalization for $CICC$ with $\beta$ reduction and 
 $\eta$ expansion.  This is the most important theorem of the section, as it implies that typechecking a Caledon 
statement will allow that statement to be compiled to pattern form to be used in proof search.  

That $CICC$ is simply an extension of $CC$ and not a modification of $CC$ implies we have the completeness theorem, \ref{ci:comp}.

\begin{theorem}
\textbf{(Completeness)}  $\forall M,T \in \m{Term}_{cc}. \vdash_{cc} M : T \implies \vdash_{ci} M : T$
\label{ci:comp}
\end{theorem}

This theorem is trivial since the syntax of $CC$ is a subset of the syntax of $CICC$.
