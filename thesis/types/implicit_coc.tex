In this section, I introduce the type inference system for Caledon. 
I first discuss the inference rules and 
erasure form of $CICC$ dubbed $CICC^-$, 
a system based on the ``Implicit Calculus of Constructions'' ($ICC$) \citep{pollack1990implicit}. 
I then introduce a unification algorithm for handling constraints generated by $CICC^-$ and finally 
describe the construction of these constraints and the elaboration technique.

$ICC$ is an extension to the standard ``Calculus of Constructions'' which allows
a declaration that in all uses of a function, the argument be omitted 
and chosen during typechecking based on a provability relation.

Standard $CC$, and even standard $LF$ 
can be unnecessarily verbose, as seen in the example \ref{code:long}.

\begin{figure}[h]
\begin{lstlisting}
defn churchList : prop -> prop
  as \ A : prop . [lst : prop -> prop] ([C] lst C) -> (A -> [C] lst C -> lst C) -> [C] lst C

defn mapCL : [A : prop] [B : prop] (A -> B) -> churchList A -> churchList B
  as \ A    : prop                    . 
     \ B    : prop                    .
     \ F    : A -> B                  . 
     \ cl   : churchList A            .
     \ lst  : prop -> prop            .
     \ nil  : [B] lst B               .
     \ cons : B -> [B] lst B -> lst B .

          cl lst nil (\v . cons (F v))

defn mapResult : churchList natural
  as mapCL natural boolean (\ a : natural . isZero a) someList

\end{lstlisting}
\caption{Maping over the church encoding of a list}
\label{code:long}
\end{figure}

Ideally, one omits redundant types whose values are parameterized 
and can be inferred from context. 

Omitting these types gives rise to the notion of an implicit type system.  
The Hindley-Milner \citep{hindley1969principal} system for inferring principle types in system F
is a special case of the system where implicit universally quantified type variables are automatically
resolved.
